import { Meta } from "@storybook/blocks";

<Meta title="Yas UI" />

# Welcome to Yas UI Docs

Please follow the conventions outlined below when developing components for Yas UI.

### We use the [Atomic Design](https://bradfrost.com/blog/post/atomic-web-design/) methodology.

Component files must be placed in a folder named after the atomic design level they belong to, ie. `atoms/Button.tsx`.

### Styling is done using [Vanilla Extract](https://vanilla-extract.style)

All styling must be done using typesafe `css.ts` files.

Vanilla Extract is encapsulated in the `@yas/ui` package, so you don't need to install it yourself.

```tsx
import {css} from "@yas/ui";

const myStyle = css.style(...); // Equivalent of using {style} from vanilla-extract/css
const myRecipe = css.recipe(...); // Equivalent of using {recipe} from vanilla-extract/recipes
```

Our [Atomic CSS framework](https://vanilla-extract.style/documentation/packages/sprinkles/) is available as `css.atoms`:

```tsx
import { css } from "@yas/ui";
const myStyle = css.atoms({
  color: "red",
  fontSize: 16,
});
```

A convenience react component factory is available as `css.styled`:

```tsx
import { css } from "@yas/ui";
import { myRecipe } from "./myStyles.css";

const MyComponent = css.styled("div", myRecipe);
```

### Component primitives provided by [Radix UI](https://www.radix-ui.com/)

Radix UI primitives are unstyled react components with logic and accessibility compatibility provided out of the box.

All we need to do when implementing a new component is to add our own styling and re-export them:

1. First, add the new primitive package dependency from `@radix-ui/react-*`.
2. Create your new component file, style and re-export the new primitive(s). [See Radix UI docs for example](https://www.radix-ui.com/docs/primitives/overview/styling#styling-with-css-in-js).

> If radix does not provide a primitive for your use case, it's either:
>
> - So simple that we easily can create our own, in which case go ahead and do it.
> - So complicated that we _have_ to create our own, in which case discuss it with the team.

### Components must be data agnostic

To maximize portability, maintainability and testability, components should not contain any data fetching logic:

```tsx
function BadComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("https://example.com/api")
      .then((res) => res.json())
      .then((data) => setData(data));
  }, []);

  return <div>{data}</div>;
}

function GoodComponent({ data }) {
  return <div>{data}</div>;
}
```

However, if a component benefits heavily from data fetching patterns, ie. pagination, infinite scrolling, etc. you should still rely on dependency injection and let the consumer provide the data fetching logic via a prop:

```tsx
function GoodComponent({ query: useQuery }) {
  const [page, setPage] = useState(1);
  const { data, isLoading, error } = useQuery({ page });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  return <Table data={data} currentPage={page} onPageChanged={setPage} />;
}
```

### Documentation & Component testing is done with [Storybook](https://storybook.js.org/).

Stories should be defined in a file next to their related component, ie. `Button.stories.tsx`

### Unit testing should rarely be necessary, but is allowed via [Vitest](https://vitest.dev/).

Never test components with vitest. Use storybook instead.
